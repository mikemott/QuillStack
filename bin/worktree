#!/bin/zsh
# QuillStack Worktree Manager
# Creates isolated worktrees for Linear issues with proper branch naming

set -e

# Auto-detect project directory and worktrees base
SCRIPT_DIR="${0:a:h}"
DETECTED_PROJECT_DIR="$(cd "$SCRIPT_DIR/.." && git rev-parse --show-toplevel 2>/dev/null || pwd)"

# Determine if we're in iCloud or local repo
if [[ "$DETECTED_PROJECT_DIR" == *"Library/Mobile Documents/com~apple~CloudDocs/Projects/QuillStack"* ]]; then
    PROJECT_DIR="/Users/mike/Library/Mobile Documents/com~apple~CloudDocs/Projects/QuillStack"
    WORKTREES_BASE="/Users/mike/Library/Mobile Documents/com~apple~CloudDocs/Projects"
elif [[ "$DETECTED_PROJECT_DIR" == *"/Users/mike/Projects/QuillStack"* ]]; then
    PROJECT_DIR="/Users/mike/Projects/QuillStack"
    WORKTREES_BASE="/Users/mike/Projects"
else
    # Fallback: use detected directory
    PROJECT_DIR="$DETECTED_PROJECT_DIR"
    WORKTREES_BASE="$(dirname "$DETECTED_PROJECT_DIR")"
fi

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Help text
show_help() {
    cat << EOF
Usage: worktree [ISSUE_ID] [OPTIONS]

Create isolated Git worktrees for QuillStack development

ARGUMENTS:
    ISSUE_ID        Linear issue ID (e.g., QUI-129)

OPTIONS:
    --no-start      Create worktree but don't start Claude
    --list          List all active worktrees
    --cleanup       Remove worktrees for merged branches
    --help          Show this help message

EXAMPLES:
    worktree QUI-129                 # Create worktree and start Claude
    worktree QUI-129 --no-start      # Just create the worktree
    worktree --list                  # Show active worktrees
    worktree --cleanup               # Clean up merged worktrees

EOF
}

# List active worktrees
list_worktrees() {
    echo -e "${BLUE}Active Worktrees:${NC}"
    cd "$PROJECT_DIR"
    git worktree list
}

# Cleanup merged worktrees
cleanup_worktrees() {
    echo -e "${BLUE}Checking for merged branches...${NC}"
    cd "$PROJECT_DIR"

    # Get list of worktrees (skip main)
    worktrees=$(git worktree list --porcelain | grep -A 2 "^worktree" | grep -v "^$" | awk '/^worktree/ {path=$2; getline; getline; branch=$2; if (branch != "refs/heads/main") print path"|"branch}')

    if [ -z "$worktrees" ]; then
        echo -e "${YELLOW}No feature worktrees found${NC}"
        return
    fi

    removed=0
    while IFS='|' read -r path branch; do
        branch_name="${branch#refs/heads/}"

        # Check if branch is merged into main
        if git branch --merged main | grep -q "^\s*${branch_name}$"; then
            echo -e "${YELLOW}Removing merged worktree: $path ($branch_name)${NC}"
            git worktree remove "$path" --force 2>/dev/null || true
            git branch -d "$branch_name" 2>/dev/null || true
            ((removed++))
        fi
    done <<< "$worktrees"

    if [ $removed -eq 0 ]; then
        echo -e "${GREEN}No merged worktrees to clean up${NC}"
    else
        echo -e "${GREEN}Removed $removed worktree(s)${NC}"
    fi
}

# Fetch Linear issue details
fetch_issue_details() {
    local issue_id="$1"

    # Use Linear CLI or API to get issue title
    # For now, we'll use a simplified approach that just uses the issue ID
    # You can enhance this to actually fetch from Linear API

    # Try to fetch using Linear MCP if available
    # This would need to be done through Claude or a separate Linear CLI tool
    # For now, return empty and let user provide description
    echo ""
}

# Create worktree for Linear issue
create_worktree() {
    local issue_id="$1"
    local auto_start="$2"

    # Validate issue ID format
    if ! [[ "$issue_id" =~ ^QUI-[0-9]+$ ]]; then
        echo -e "${RED}Error: Invalid issue ID format. Expected QUI-XXX${NC}"
        echo "Example: worktree QUI-129"
        exit 1
    fi

    cd "$PROJECT_DIR"

    # Check if we're in main branch
    current_branch=$(git branch --show-current)
    if [ "$current_branch" != "main" ]; then
        echo -e "${YELLOW}Warning: Not on main branch (currently on: $current_branch)${NC}"
        read -p "Continue anyway? (y/n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit 0
        fi
    fi

    # Sync with remote
    echo -e "${BLUE}Syncing with remote...${NC}"
    git fetch origin main:main 2>/dev/null || git fetch origin

    # Try to fetch issue title
    issue_title=$(fetch_issue_details "$issue_id")

    # If we couldn't fetch the title, ask user
    if [ -z "$issue_title" ]; then
        echo -e "${YELLOW}Enter a short description for $issue_id (or press Enter to skip):${NC}"
        read -r issue_title
    fi

    # Create branch name
    issue_id_lower=$(echo "$issue_id" | tr '[:upper:]' '[:lower:]')
    if [ -n "$issue_title" ]; then
        # Convert title to branch name format
        branch_suffix=$(echo "$issue_title" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | sed 's/[^a-z0-9-]//g' | cut -c1-40)
        branch_name="${issue_id_lower}-${branch_suffix}"
    else
        branch_name="${issue_id_lower}"
    fi

    # Check if branch already exists
    if git show-ref --verify --quiet "refs/heads/$branch_name"; then
        echo -e "${RED}Error: Branch '$branch_name' already exists${NC}"
        echo "Existing worktrees:"
        git worktree list
        exit 1
    fi

    # Create worktree path
    worktree_name="quillstack-${issue_id_lower}"
    worktree_path="${WORKTREES_BASE}/${worktree_name}"

    # Check if worktree directory already exists
    if [ -d "$worktree_path" ]; then
        echo -e "${RED}Error: Directory already exists: $worktree_path${NC}"
        exit 1
    fi

    # Create the worktree
    echo -e "${BLUE}Creating worktree...${NC}"
    git worktree add "$worktree_path" -b "$branch_name"

    echo ""
    echo -e "${GREEN}âœ“ Created worktree${NC}"
    echo -e "  ${BLUE}Path:${NC}    $worktree_path"
    echo -e "  ${BLUE}Branch:${NC}  $branch_name"
    echo -e "  ${BLUE}Issue:${NC}   $issue_id"
    echo ""

    # Update Linear issue status to "In Progress" (optional)
    # This would require Linear API integration

    if [ "$auto_start" = "true" ]; then
        echo -e "${BLUE}Starting Claude in new worktree...${NC}"
        cd "$worktree_path"
        exec claude
    else
        echo -e "${YELLOW}Next steps:${NC}"
        echo "  cd \"$worktree_path\""
        echo "  claude"
        echo ""
        echo -e "${BLUE}Tip:${NC} Run 'worktree --list' to see all active worktrees"
    fi
}

# Main script logic
main() {
    # Parse arguments
    auto_start="true"
    issue_id=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            --help|-h)
                show_help
                exit 0
                ;;
            --list|-l)
                list_worktrees
                exit 0
                ;;
            --cleanup|-c)
                cleanup_worktrees
                exit 0
                ;;
            --no-start)
                auto_start="false"
                shift
                ;;
            QUI-*)
                issue_id="$1"
                shift
                ;;
            *)
                echo -e "${RED}Error: Unknown argument: $1${NC}"
                show_help
                exit 1
                ;;
        esac
    done

    # If no issue ID provided, show help
    if [ -z "$issue_id" ]; then
        show_help
        exit 1
    fi

    # Create the worktree
    create_worktree "$issue_id" "$auto_start"
}

main "$@"
